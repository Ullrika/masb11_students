<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="sv" xml:lang="sv"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Skriv ditt namn här">

<title>Centrala Gränsvärdessatsen (CGS)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Lab2_student_rapport_files/libs/clipboard/clipboard.min.js"></script>
<script src="Lab2_student_rapport_files/libs/quarto-html/quarto.js"></script>
<script src="Lab2_student_rapport_files/libs/quarto-html/popper.min.js"></script>
<script src="Lab2_student_rapport_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Lab2_student_rapport_files/libs/quarto-html/anchor.min.js"></script>
<link href="Lab2_student_rapport_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Lab2_student_rapport_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Lab2_student_rapport_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Lab2_student_rapport_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Lab2_student_rapport_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Andra format</h2><ul><li><a href="Lab2_student_rapport.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li><li><a href="Lab2_student_rapport.docx"><i class="bi bi-file-word"></i>MS Word</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Centrala Gränsvärdessatsen (CGS)</h1>
<p class="subtitle lead">Datorlaboration 2</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Författare</div>
    <div class="quarto-title-meta-contents">
             <p>Skriv ditt namn här </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Publicerad</div>
    <div class="quarto-title-meta-contents">
      <p class="date">12 mars 2025</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstrakt</div>
    <p>Syftet med dagens laboration är att du ska:</p>
    <ul>
    <li>illustrera centrala gränsvärdessatsen (CGS) med hjälp av simulering</li>
    <li>använda CGS i en praktisk situation</li>
    </ul>
  </div>
</div>


</header>


<section id="förberedelseuppgifter" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="förberedelseuppgifter">Förberedelseuppgifter</h2>
<p>Repetera begreppen <em>normalfördelning, väntevärde och varians för en summa (eller medelvärde) av oberoende slumpvariabler</em>.</p>
<p>Du skall ha gjort följande uppgifter <strong>innan</strong> du kommer till laborationen.</p>
<div class="callout callout-style-default callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hemuppgift 1
</div>
</div>
<div class="callout-body-container callout-body">
<p>Gör <strong>Dig:3.3.2_5</strong> och <strong>3.96</strong> och <strong>Dig:3.4.5_1</strong> på övning 5.</p>
</div>
</div>
<div class="callout callout-style-default callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hemuppgift 2
</div>
</div>
<div class="callout-body-container callout-body">
<p>Försök att med egna ord beskriva vad centrala gränsvärdessatsen säger.</p>
</div>
</div>
<div class="callout callout-style-default callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hemuppgift 3
</div>
</div>
<div class="callout-body-container callout-body">
<p>Repetera vad du gjorde vid laboration 1 och vilka metoder du använder för att simulera slumptal och för att anpassa en fördelning till data och att beräkna sannolikheter eller kvantiler från den anpassade fördelningen.</p>
</div>
</div>
</section>
<section id="centrala-gränsvärdessatsen" class="level1">
<h1>Centrala gränsvärdessatsen</h1>
<blockquote class="blockquote">
<p>Adderar man (eller beräknar medelvärdet) av flera oberoende normalfördelade slumpvariabler är summan också normalfördelad. Men vad händer om man lägger ihop flera variabler som alla är rektangelfördelade? Vilken fördelning fås om man adderar exponentialfördelade variabler?</p>
<p>Centrala gränsvärdessatsen (CGS) säger att om man adderar ett stort antal oberoende variabler från en godtycklig fördelning blir summan (eller medelvärdet) normalfördelad. I formler: om <span class="math inline">\(n\)</span> är tillräckligt stort gäller att <span class="math inline">\(Z_n = X_1 + X_2 + \ldots + X_n\)</span> är approximativt normalfördelad oavsett vilket fördelning <span class="math inline">\(X_1, \ldots, X_n\)</span> har. Med några simuleringar ska du undersöka om detta tycks stämma, där vi utgår från några olika fördelningar för <span class="math inline">\(X\)</span>-variablerna.</p>
</blockquote>
<section id="uppgift-1.1" class="level3">
<h3 class="anchored" data-anchor-id="uppgift-1.1">Uppgift 1.1</h3>
<p>Simulera 1000 slumptal från en rektangelfördelning, <span class="math inline">\(R(0, 1)\)</span> och lägg dem i variabeln <code>unif1</code>. Använd <code>hist()</code> och <code>qqnorm()</code> för att konstatera att slumptalen är rektangelfördelade och definitivt inte passar till en normalfördelning. :::</p>
<div class="cell">
<details class="code-fold">
<summary>Kod</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>unif1 <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="dv">1000</span>,<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(unif1)</span></code><button title="Kopiera till Urklipp" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Lab2_student_rapport_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<details class="code-fold">
<summary>Kod</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">qqnorm</span>(unif1)</span></code><button title="Kopiera till Urklipp" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Lab2_student_rapport_files/figure-html/unnamed-chunk-1-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="uppgift-1.2" class="level3">
<h3 class="anchored" data-anchor-id="uppgift-1.2">Uppgift 1.2</h3>
<p>Simulera 1000 nya slumptal från en rektangelfördelning, <span class="math inline">\(R(0, 1)\)</span> och lägg dem i variabeln <code>unif2</code>. Summera sedan de gamla och de nya slumptalen genom <code>sum12 &lt;- unif1+unif2</code>. Resultatet är 1000 slumptal från <span class="math inline">\(Z_2 = X_1 + X_2\)</span>. Använd <code>hist()</code> och <code>qqnorm()</code> för att undersöka fördelningen hos denna summa :::</p>
<div class="cell">
<details class="code-fold">
<summary>Kod</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>unif2 <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="dv">1000</span>,<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>sum12 <span class="ot">&lt;-</span> unif1 <span class="sc">+</span> unif2</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># skriv din R-kod här</span></span></code><button title="Kopiera till Urklipp" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="uppgift-1.3" class="level3">
<h3 class="anchored" data-anchor-id="uppgift-1.3">Uppgift 1.3</h3>
<p>Skapa fler slumpvariabler <code>unif3</code>, <code>unif4</code> och <code>unif5</code> på motsvarande sätt och studera fördelningen för <span class="math inline">\(X_1+X_2+\ldots+X_5\)</span>. Verkar det rimligt att ju större <span class="math inline">\(n\)</span> är, desto bättre kan fördelningen för summan anpassas till en normalfördelning? :::</p>
<div class="cell">
<details class="code-fold">
<summary>Kod</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>sum12345 <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="dv">1000</span>,<span class="dv">0</span>,<span class="dv">1</span>) <span class="sc">+</span> <span class="fu">runif</span>(<span class="dv">1000</span>,<span class="dv">0</span>,<span class="dv">1</span>) <span class="sc">+</span> <span class="fu">runif</span>(<span class="dv">1000</span>,<span class="dv">0</span>,<span class="dv">1</span>) <span class="sc">+</span> <span class="fu">runif</span>(<span class="dv">1000</span>,<span class="dv">0</span>,<span class="dv">1</span>) <span class="sc">+</span> <span class="fu">runif</span>(<span class="dv">1000</span>,<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># skriv din R-kod här</span></span></code><button title="Kopiera till Urklipp" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Svar</strong>: <!-- ta bort detta och skriv dina slutsatser i enkel text --></p>
</section>
<section id="uppgift-1.4" class="level3">
<h3 class="anchored" data-anchor-id="uppgift-1.4">Uppgift 1.4</h3>
<p>Pröva vad som händer då du summerar exponentialfördelade slumvariabler med väntevärde 1 (<code>rexp(1000,1)</code>). Hur många variabler behövs summeras innan summan kan approximeras med en normalfördelning? :::</p>
<div class="cell">
<details class="code-fold">
<summary>Kod</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># du kan exempelvis göra en for-loop för att utföra beräkningarna </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>n <span class="ot">=</span> <span class="dv">10</span> <span class="co"># antal oberoende slumpvariabler - ändra tills du tycker summan ser normalfördelad ut</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>sumn <span class="ot">&lt;-</span> <span class="fu">rexp</span>(<span class="dv">1000</span>,<span class="dv">1</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>(n<span class="dv">-1</span>)){</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  sumn <span class="ot">&lt;-</span> sumn <span class="sc">+</span> <span class="fu">rexp</span>(<span class="dv">1000</span>,<span class="dv">1</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(sumn)</span></code><button title="Kopiera till Urklipp" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Lab2_student_rapport_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<details class="code-fold">
<summary>Kod</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">qqnorm</span>(sumn)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">qqline</span>(sumn)</span></code><button title="Kopiera till Urklipp" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Lab2_student_rapport_files/figure-html/unnamed-chunk-4-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>Svar</strong>: <!-- ta bort detta och skriv dina slutsatser i enkel text --></p>
</section>
</section>
<section id="cgs-i-praktiken" class="level1">
<h1>CGS i praktiken</h1>
<blockquote class="blockquote">
<p>På 35 patienter med Hodgkins sjukdom mätte man antalet T4 celler i blodet (antal/mm3). Samtidigt mätte man motsvarande antal hos 35 patienter som hade andra sjukdomar (Non-Hodgkins). Data ligger i filen <code>data/lab2_filer/Hodgkindata.RData</code>. Läs in data med <code>load()</code>. Du har nu fått två nya variabler Hodgkin och NonHodgkin.</p>
</blockquote>
<div class="cell">
<details class="code-fold">
<summary>Kod</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">"data/lab2_filer/Hodgkindata.RData"</span>)</span></code><button title="Kopiera till Urklipp" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="uppgift-2.1" class="level3">
<h3 class="anchored" data-anchor-id="uppgift-2.1">Uppgift 2.1</h3>
<p>Undersök om antalet celler i blodet är normalfördelat för de båda grupperna. :::</p>
<div class="cell">
<details class="code-fold">
<summary>Kod</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># skriv din R-kod här</span></span></code><button title="Kopiera till Urklipp" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Svar</strong>: <!-- ta bort detta och skriv dina slutsatser i enkel text --></p>
</section>
<section id="uppgift-2.2" class="level3">
<h3 class="anchored" data-anchor-id="uppgift-2.2">Uppgift 2.2</h3>
<p>Det kan vara intressant att jämföra grupperna genom att bilda differensen mellan de två gruppmedelvärdena. Använd dig av centrala gränsvärdessatsen för att säga något om vilken fördelning differensen i stickprovsmedelvärden har. :::</p>
<p><strong>Modell</strong>:</p>
<p>Låt <span class="math inline">\(\mu_{Hodgkin}\)</span> och <span class="math inline">\(\mu_{NonHodgkin}\)</span> vara väntevärden i de två grupperna.</p>
<p>Låt <span class="math inline">\(\sigma^2_{Hodgkin}\)</span> och <span class="math inline">\(\sigma^2_{NonHodgkin}\)</span> vara varianser i de två grupperna.</p>
<p>Vi har två stickprov <span class="math inline">\((x_1,...,x_{35})\)</span> och <span class="math inline">\((y_1,...,y_{35})\)</span> från grupperna med Hodgkin respektive NonHodgkin.</p>
<p>Differensen mellan stickprovsmedelvärden är <span class="math inline">\(\delta = \bar{x}- \bar{y}\)</span> och har följande fördelning</p>
<p><span class="math inline">\(\delta \sim ...\)</span> fyll i beskrivningen! Kolla med labhandledare att du har rätt fördelning</p>
</section>
<section id="uppgift-2.3" class="level3">
<h3 class="anchored" data-anchor-id="uppgift-2.3">Uppgift 2.3</h3>
<p>Skatta parametrarna (väntevärde och varians) i fördelningen för differensen <span class="math inline">\(\delta\)</span>. Ange värdet på parametrarna. :::</p>
<div class="cell">
<details class="code-fold">
<summary>Kod</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># skriv din R-kod här</span></span></code><button title="Kopiera till Urklipp" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Svar</strong>: <span class="math inline">\(\hat{\mu}_{\delta}\)</span>= och <span class="math inline">\(\hat{\sigma}_{\delta}\)</span>=</p>
<!-- fyll i värdena  -->
</section>
<section id="uppgift-2.4" class="level3">
<h3 class="anchored" data-anchor-id="uppgift-2.4">Uppgift 2.4</h3>
<p>Är det ett stort problem att antal celler i bloder inte är normalfördelad i de båda grupperna från början? Föreställ dig en situtation där det är ett problem och ge ett förslag på hur man kan åtgärda det? :::</p>
<p><strong>Svar</strong>: <!-- ta bort detta och skriv dina slutsatser i enkel text --></p>
</section>
</section>
<section id="provtagningstider---problemställningar-från-labbet" class="level1">
<h1>Provtagningstider - problemställningar från labbet</h1>
<p>Målsättningen med denna uppgift är att du ska</p>
<ul>
<li><p>träna på att hämta ett problem ur verkligheten och med hjälp av ett insamlat material konstruera en rimlig statistisk modell,</p></li>
<li><p>göra en kritisk granskning av modellen och dess förmåga att beskriva verkligheten,</p></li>
<li><p>tillämpa dina kunskaper och med hjälp av R analysera ett biostatistiskt datamaterial, och</p></li>
<li><p>träna på att skriftligt redovisa antaganden, modeller och slutsatser från en statistisk analys.</p></li>
</ul>
<section id="bakgrund" class="level2">
<h2 class="anchored" data-anchor-id="bakgrund">Bakgrund</h2>
<p>Vid vårt kemilaboratorium analyserar vi bland annat en rad prover från den näraliggande provtagningscentralen. Det har framkommit starka önskemål om att vissa patienter som tar prover ska kunna träffa en läkare vid samma besök och inte behöva boka in olika dagar för provtagning och läkarbesök. För att detta önskemål ska uppfyllas måste vi förstås veta hur lång tid det tar från det att provet tagits på patienten till analyssvaret är klart och undersöka om det är rimligt att låta patienter vänta på provsvar samma dag. Det finns flera moment att ta hänsyn till: provet kan få vänta på provtagningscentralen tills det blir hämtat till vårt laboratorium, det behövs en viss manuell handläggningstid av provet och slutligen har vi själva processtiden i maskinen. Dessutom har vi lite olika hanteringstider beroende på vilken dag i veckan det är och om det är för- eller eftermiddag.</p>
<p>I datafilerna <code>data/lab2_filer/proverfm24.RData</code> och <code>data/lab2_filer/proverem24.RData</code> finns det tider (minuter) som det tog “från patientarm till analyssvar”. Provet är på så kallad “allmän kemi” och, som ni märker, har vi har delat upp data i två filer, en för prover tagna på förmiddagen ´tidfm´ och en för prover tagna på eftermiddagen. ´tidem´. När vi gör ett histogram på dessa data ser vi att de inte verkar följa en normalfördelning. Det verkar rimligt eftersom tid har en nedre begränsning. Det innebär att vi bör använda en lämplig fördelning för att modellera väntetider i denna uppgift.</p>
</section>
<section id="uppgifter" class="level2">
<h2 class="anchored" data-anchor-id="uppgifter">Uppgifter</h2>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tips
</div>
</div>
<div class="callout-body-container callout-body">
<p>Läs igenom avsnitten Föreslagen arbetsgång och Instruktioner för rapportering före du löser uppgift 3.1 till 3.4</p>
</div>
</div>
<section id="uppgift-3.1." class="level3">
<h3 class="anchored" data-anchor-id="uppgift-3.1.">Uppgift 3.1.</h3>
<p>Hur sannolikt är det att en förmiddagspatient får vänta mer än två timmar på analyssvar?</p>
</section>
<section id="uppgift-3.2." class="level3">
<h3 class="anchored" data-anchor-id="uppgift-3.2.">Uppgift 3.2.</h3>
<p>Vi vill kunna säga att 95% av eftermiddagspatienterna kommer att ha sitt provsvar snabbare än <span class="math inline">\(y\)</span> minuter. Vad är den statistiska termen för <span class="math inline">\(y\)</span>? Vilket värde har <span class="math inline">\(y\)</span> enligt den modell du har valt för eftermiddagsstider?</p>
</section>
<section id="uppgift-3.3." class="level3">
<h3 class="anchored" data-anchor-id="uppgift-3.3.">Uppgift 3.3.</h3>
<p>Det brukar vara något fler patienter på eftermiddagen jämfört med på förmiddagen. Låt oss anta att 60,% av patienter kommer på förmiddagen och resten på eftermiddagen. Hur troligt är det att ett patientprov, taget någon gång under dagen, tar mer än två timmar att analysera?</p>
</section>
<section id="uppgift-3.4." class="level3">
<h3 class="anchored" data-anchor-id="uppgift-3.4.">Uppgift 3.4.</h3>
<p>Om vi har 25 patientprover på förmiddagen, vad är sannolikheten att <strong>genomsnittstiden</strong> för dessa 25 prov överstiger en timme?</p>
</section>
</section>
<section id="föreslagen-arbetsgång" class="level2">
<h2 class="anchored" data-anchor-id="föreslagen-arbetsgång">Föreslagen arbetsgång</h2>
<ul>
<li><p>Titta på data (histogram, empirisk fördelningsfunktion). Beräkna enkla mått (medelvärde, standardavvikelse). Jämför förmiddags- och eftermiddagstider.</p></li>
<li><p>Sätt upp en lämplig modell (sannolikhetsfördelning) för förmiddagstiderna och skatta parametrarna i modellen.</p></li>
<li><p>Gör samma sak för eftermiddagstiderna.</p></li>
<li><p>Svara på frågorna (3.1)–(3.3) genom att utnyttja de anpassade modellerna (sannolikhetsfördelningarna) för för- respektive eftermiddagstider.</p></li>
<li><p>Fundera på vilken sannolikhetsfördelning som passar som modell för genomsnittstiden (medelvärdet) av 25 förmiddagstider. Ange vilket teoretiskt resultat (hänvisa till en känd sats) du använder för att motivera ditt val av modell! Använd de “enkla mått” du beräknade tidigare (medelvärde och standardavvikelse för stickprovet) för att skatta parametrar i din modell för genomsnittstiden.</p></li>
</ul>
</section>
<section id="instruktioner-för-rapportering" class="level2">
<h2 class="anchored" data-anchor-id="instruktioner-för-rapportering">Instruktioner för rapportering</h2>
<p>Ange (om så är lämpligt):</p>
<ul>
<li><p>vilka antaganden du gör om data,</p></li>
<li><p>vilka modeller du ställer upp,</p></li>
<li><p>vilka satser du använder.</p></li>
<li><p>Redovisa resultat av analysen och vilka tolkningar och slutsatser du gör.</p></li>
<li><p>Sammanfatta dina resultat för provtagningstider.</p></li>
<li><p>Undvik hänvisa till R-kod för att beskriva vad du har gjort</p></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopieras!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopieras!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>